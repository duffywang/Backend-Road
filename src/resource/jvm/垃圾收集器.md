## 垃圾收集器
垃圾收集器由两步构成：
- 查找不再使用的对象
- 释放这些对象所管理的内存



### Serial收集器
单线程清理堆的内存，无论是进行Young GC还是Full GC，清理堆空间时，所有的应用线程都会被暂停；
-XX:+UseSerialGC开启Serial收集器
适用应用层序内存少于100MB的场景
### Parallel（Throughput）收集器
使用多线程回收新生代空间，Young GC的速度比使用Serial收集器快得多，在Young GC还是Full GC时会暂停所有应用线程
-XX:+UseparallelGC -XX:+UseParallelOldGCad

### CMS收集器
CMS出现是为了解决Serial和Parallel收集器Full GC长时间停顿的
CMS是老年代垃圾回收器，新生代配合的是-XX:+UseParNewGC
后台线程不再进行任何压缩整理工作，堆会变得碎片化

如果CMS后台线程无法获得完成他们任务所需的CPU资源时，或者过度碎片化以至于无法找到连续空间分配对象，CMS退化为Serial单线程收集器,整理老年代空间

### G1收集器
G1垃圾优先收集器的设计初衷是为了尽量缩短处理超大堆（大于4GB）时产生的停顿
G1算法将堆划分为若干个区域（Region）
G1收集器属于Concurrent收集器，但是后台线程会进行堆的压缩整理，使用G1收集器的堆不大容易发生碎片化，故比CMS更不容易遭遇Full GC

评估垃圾收集器时，思考希望达到的性能目标，每一个决定都需要权衡取舍
- 如果尽可能缩短响应时间，那么选择Concurrent收集器，使用Concurrent收集器可能会遭遇长时间的Full GC，并且Concurrent收集器会消耗CPU资源