# 高可用架构设计之高性能



### 引子

**性能的衡量指标**

从工作负载角度

- 延时（AVG、TP99）：应用程序平均时延为5ms，95%请求延时在100ms以下
- 吞吐量（QPS、TPS）：最大吞吐量 每台服务器10000次应用请求/秒
- 资源使用率：在每秒10000次应用请求情况下，平均磁盘使用率在50%以下

对于延时而言，限制因素可能是磁盘或者网络IO;对于吞吐量，可能是CPU

一些方法可能只对一个目标奏效，而对另一个不奏效，选择更大IO会以牺牲延时为代价来提高吞吐量

从资源角度分析

- CPU
- 内存
- 磁盘

资源使用率

#### 应用程序性能方法

- 线程状态分析

- CPU剖析

  判断应用程序是如何消耗CPU资源的，可使用

- 系统调用分析

- IO剖析

- 工作负载特性分析

- 锁分析



## 应用程序性能技术

#### 选择IO尺寸

增加IO尺寸是应用程序提高吞吐量的常用策略，考虑到每次IO的固定开销，一次IO传输128KB要比128次传输1KB高效的多。尤其是磁盘IO，由于寻道时间，每次IO开销都较高

如果应用程序不需要，更大的IO尺寸也会带来负面效应，一个执行8KB读取的数据库按128KB IO尺寸运行会慢得多，选择小一些的IO尺寸更贴近应用程序所需，能降低引起的IO延时



**性能优化的视角**

应用层（业务流程调优、数据结构与算法调优）

——VM（JVM调优）

——操作系统与软件栈（系统参数、内核参数、进程参数、文件系统）

——设备（CPU、内存、磁盘、网卡）



## 性能优化策略

### 资源优化

CPU、内存、硬盘、网卡



### 业务流程优化

设计合理的业务流程

- 简化流程复杂度

- 无依赖流程并行

- 非主流程异步：辅助流程从核心流程种拆分、独立的线程处理、异步队列

- IO异步，采用NIO

  对于多路并发IO,当阻塞时，每一个阻塞的IO都会消耗一个线程，应用程序必须创建很多线程，伴随着线程的创建、销毁以及频繁发生的短时IO,频繁切换上下文开销会增加应用程序的延时

### 面向GC优化

- 对象重用：低成本的局部对象，随意建；线程池、连接池；线程安全对象全局唯一；线程不安全对象ThreadLocal或对象池
- Immutable对象：线程安全；避免死锁造成内存泄露；全局唯一
- 堆外内存：有一定序列化/反序列化开销；对GC没有负担
- 集合大小初始化：当map长期存在减小负载因子，用空间换时间
- 内存泄露：数据不再使用，但有集合引用

### 数据优化

采用缓存

提高系统的读性能和内存分配性能

- 本地缓存：堆内缓存Guava Cache ,有增加GC压力，拉高TP99;堆外缓存EHCache,有序列化/反序列化开销
- 中心缓存：全局缓存，有RPC开销
- 多级缓存

缓存过期策略

- 根据过期时间的：清理最长时间没用过的、清理即将过期的、任意清理一个
- 无论是否过期的：随机清理、根据LRU原则清理

采用池化技术

- 对象池
- 连接池
- 线程池





### RPC优化

- 数据本地化、内存化，避免RPC
- 数据合并、批量处理

### 计算优化

计算复杂度优化

- 算法复杂度大O分析：O(1) O(log(n)) O(n) O(nlog(n)) O(n2) O(2^n) O(n!)
- 空间换时间
- 分批并行：

并发与锁

锁的分类

- 多个线程是否可以共享同一把锁：共享锁、排他锁
- 同一个线程是否可以获取同一把锁：可重入锁、不可重入锁
- 资源获取失败时是否阻塞：阻塞、不阻塞（自旋锁、适应性自旋锁）
- 是否需要锁资源：悲观锁、乐观锁
- 竞争锁时是否排队：公平锁、非公平锁
- 多线程竞争流程时锁升级：无锁、偏向锁、轻量级锁、重量级锁

锁的优化

- 缩短锁：synchronized代码块尽量短，多个断断续续的块可以合并

- 分离锁：ReadWriteLock 、ArrayBlockQueue全局一把锁、LinkedBlockingQueue队头队尾两把锁

- 分散锁：ConcurrentHashMap默认分成16Segment

- CAS：CompareAndSet 自旋、Atomic*系列类

- ThreadLocal：ThreadLocalRandom 、SimpleDateFormat in ThreadLocal

- Immutable：CopyOnWriteArrayList

  